//
//  main.c
//  6.1
//
//  Created by Hsieh Yu Hua on 2013/12/3.
//  Copyright (c) 2013å¹´ Hsieh Yu Hua_NTHU_s102062210. All rights reserved.
//

#define how_many_line 100
#define size_of_line 1024

#define how_many_sliced 100
#define each_slice_long 50
#include <string.h>
#include <stdio.h>

//from line 36
//this is used to stored every element chooped.
struct chooped
{
    char chopped_stack_element[each_slice_long];
    int times;//how many times the same word appeard.
}chopped_stack[how_many_sliced],chopped_stack_table[how_many_sliced];
//table is used to store every distinct word.

int slash(char (*stack)[size_of_line],int i,struct chooped *chopped_stack);
void sort(struct chooped *stack,int i);
int tabalize(struct chooped *chopped_stack_table,struct chooped *chopped_stack,int chop_times);

int main(int argc, const char * argv[])
{
    char stack[how_many_line][size_of_line]={0};
    int i=0;
    while (1)
    {
        if(gets(stack[i]))
        {
            int chop_times=0;
            
            chop_times=slash(stack,i,chopped_stack);
            //slash every input line into non-space condition,e.g.[I love u]==>[I][love][u]
            //and store into chopped_stack;
            //the return value is how many times it chopped a sentence.
            //e.g.i am a lolicon = 4
            
            tabalize(chopped_stack_table, chopped_stack,chop_times);
            
            sort(chopped_stack,chop_times);
            ////bubble sort to sort each line alphabetically.
            //sort every element in chopped_stack into alphabetically.
            //and record how many times each word appeared.
            
            /*for (int k=0; k<chop_times; k++) {
                printf("%s %d\n",chopped_stack[k].chopped_stack_element,chopped_stack[k].times);
            }*/
            
            i++;//record how many stack used right now.
        }
        else//While the ENTER is "EOF".end this program.
        {
            return 0;
        }
    }
}


void sort(struct chooped *data,int i)
{
    char temp[30];
    for (int j=i-1; j>0; j--)
    {
        for (int k=0; k<=j-1; k++)
        {
            if (strcmp(data[k].chopped_stack_element,data[k+1].chopped_stack_element)<0)
            {
                strcpy(temp, data[k].chopped_stack_element);
                strcpy(data[k].chopped_stack_element, data[k+1].chopped_stack_element);
                strcpy(data[k+1].chopped_stack_element, temp);
            }
        }
    }
}

int slash(char (*stack)[size_of_line],int i,struct chooped *chopped_stack)
{
    int j=0;
    char *token;
    char *seps=" ";
    token = strtok( stack[i], seps );   /* Establish string and get the first token: */
    while( token != NULL )
    {
        strcpy(chopped_stack[j].chopped_stack_element, token);
        token = strtok( NULL, seps );   /* Get next token: */
        j++;
    }
    return j;
}

int tabalize(struct chooped *chopped_stack_table,struct chooped *chopped_stack,int chop_times)
{
    int has_or_no=0;
    int i=0;//how many elements are in the new_table.=return value
    int j=1;
    strcpy(chopped_stack_table[0].chopped_stack_element,chopped_stack[0].chopped_stack_element);
    chopped_stack_table[0].times++;
    int k=1;
    do
    {
        for (int i=0; i<k; i++)
        {
            if (strcmp(chopped_stack_table[i].chopped_stack_element, chopped_stack[j].chopped_stack_element)==1)
            {
                //FIND THE SAME ELEMENT
                chopped_stack_table[i].times++;
                has_or_no++;
                break;
            }
        }
        if (has_or_no==0) {//NOT FIND THE SAME ELEMENT
            strcpy(chopped_stack_table[k].chopped_stack_element,chopped_stack[j].chopped_stack_element);
            chopped_stack_table[k].times++;
            j++;
            k++;
            has_or_no=0;
        }
        j++;
    }while(j<chop_times);
    
    for (int s=0; s<k; s++) {
        printf("%s %d\n",chopped_stack_table[s].chopped_stack_element,chopped_stack_table[s].times);
    }

    return i;
}


